## PID
这一部分主要讲解机器人控制的基础，也就是PID控制器。它的主要功能是帮助你控制系统到达指定的状态，例如：机器人前进1m，抬升机构抬升90°，机器人速度保持1m/s等等。一个调校良好的PID控制器，是实现高效、精准运动的利器。
PID控制器包含三大核心组件：比例（Proportional）、积分（Integral）、微分（Derivative），其名称即来源于这三个词的首字母。不过，实际应用中并不一定要三者俱全——你可以只用P控制器、PI控制器或PD控制器。

***

### PID的背景
在深入了解PID控制器之前，我们先简单回顾一下它的历史：
- 1922年，俄裔美国工程师 Nicolas Minorsky 首次从理论上提出了PID控制器，用于自动船舶转向。他通过观察舵手的操作，发现其不仅考虑当前航向误差，还会参考过去的误差以及误差的变化速率。于是，他将这一行为数学化，提出了PID控制理论。
- 最初，比例控制（P）足以应对小扰动，但无法消除稳态误差（如强风影响），于是加入了积分（I）；为进一步提升稳定性，又引入了微分（D）。
- 实验在 New Mexico 号战舰上进行，PI控制使偏航误差保持在±2°，而加入D后，误差降至±1/6°，优于大多数人类舵手。

在机器人编程中，常见的基础控制逻辑是：“以恒定功率运行，直到到达某个位置后停止”。在理想情况下，这样做确实可以精确停在目标点。事实上，速度的变化是需要时间的，当你发出停止的命令后，机器并不会立刻停下来，而是会有一个减速的过程，那么就会导致和目标值的偏差。在现实世界中，也存在许多不可预测的因素会导致系统超过目标点，例如动量（受速度和电池电压影响）或其他外部干扰。

![PID1](/attachment/picture/PID1.PNG)

***

###  比例控制-P
比例控制部分为系统提供主要的控制动力。其核心思想是：**距离目标远时提供大功率**，系统迅速缩小误差，靠齐目标值，**距离目标近时提供小功率**，系统已经接近目标值，就不需要很高的功率输出去靠齐，从而实现**平滑减速**。

#### 误差-Error
首先，我们定义一个变量，称为误差（error）。它非常简单，就是当前传感器值与你希望达到的目标值之间的差值。例如，误差可以是剩余距离、剩余高度等。如果你的手机电量是30%，而你希望充到100%，那么误差就是70%。因此，误差就是你的***期望值和当前值的差异大小***，数学上可以表示为：
- 误差 = 目标值（setpoint） - 当前传感器值

例如，机器人要前进1000单位：

| 目标值  | 当前值  | 误差   |
| ---- | ---- | ---- |
| 1000 | 0    | 1000 |
| 1000 | 200  | 800  |
| ...  | ...  | ...  |
| 1000 | 1200 | -200 |

:warning:这里误差出现了负数，需要说明的是，这里的负号并不是指大小，而是方向。误差也是有方向的，代表了当前值是差的多了还是差的少了。因此这里的-200，代表了当前值大于了目标，也就是系统 “走过头了” 。

#### 输出功率分配
为了实现比例控制带来的平滑减速效果，我们可以直接将电机功率设置为误差值：

```c++
power = error
```

但你可能会发现，这样设置的功率值并不合适。机器人可能过于“温柔”，甚至在接近目标时无法到达；或者过于“激进”，导致严重超调并不断震荡。

为解决此问题，我们引入一个比例常数（kP），将误差乘以kP后作为输出功率：

```c++
error = setpoint - sensor_value
power = error * kP
```

我们还需要将上述逻辑放入一个循环中，以便实时更新误差和功率：

```c++
void PID(int setpoint) {
    while (condition) {
        error = setpoint - sensor_value;
        power = error * kP;
    }
}
```

***

### 积分控制-I
你可能还记得我们在介绍中提到，比例项对于小扰动是足够的，但对于更强的扰动（例如，在自动船舶转向的情况下的“强风”）就不够了。积分项将在处理其他扰动时为我们提供一些多样性。你可能还会发现，随着比例组件的误差变小，系统的功率也非常小，可能会看到一些显著的剩余误差根本没有消除，而积分将通过缓慢增加功率来消除这些误差。积分将回顾系统随时间计算的所有误差。根据定义，积分是微积分中曲线下的面积，这里我们用简单的方法来做，通过求和许多薄片的面积来计算总面积。

#### 理解积分
下面的示例显示了一个曲线，其面积使用矩形片来估计——就像我们将用代码做的那样。每一片的高度与误差相同，有一个恒定的宽度，我们将称之为“dT”。正如我们所看到的，它并不完美，但对面积有一个不错的估计。dT 的值越小（片越薄），我们对面积的估计就越准确。

![PID2](/attachment/picture/PID2.PNG)

我们循环的每一次迭代的“曲线下的面积”将是当前误差乘以循环迭代所需的时间。这是一个粗略的近似，但对于我们这些薄片来说已经足够了。

```c++
area = error * dT
```

积分等于所有这些面积的总和。在任何时候，它都是之前所有循环的面积之和，所以我们创建一个变量 “积分” ，并在我们循环的每一次迭代中加上新的面积片：

```c++
integral = integral + error*dT
```

由于 dT 通常是我们自己设置的恒定延迟（例如，每次循环迭代等待 15 毫秒），我们可以稍后将其中分解出来，因此倾向于忽略它的存在。因此，我们将使用这个公式来计算我们的积分：

```c++
integral = integral + error 
```

考虑一个情况，我们的误差以一个很好的恒定速率下降（理想情况下），忽略 dT。下表描述了积分将如何计算：

| 循环编号 | 误差   | 积分   |
| ---- | ---- | ---- |
| 1    | 1000 | 1000 |
| 2    | 800  | 1800 |
| 3    | 600  | 2400 |
| 4    | 400  | 2800 |
| 5    | 200  | 3000 |

现在，考虑如果有某种外部影响导致我们的误差下降得更慢会发生什么。在上面的示例中，它每循环减少 200 个单位。下一个表格考虑如果那是 100 会怎样：

| 循环编号 | 误差   | 积分   |
| ---- | ---- | ---- |
| 1    | 1000 | 1000 |
| 2    | 900  | 1900 |
| 3    | 800  | 2700 |
| 4    | 700  | 3400 |
| 5    | 600  | 4000 |

正如我们所看到的，在第一个示例中，我们的积分在 5 个循环后是 3000。现在，随着减速变慢，它是 4000。这个值的增加是我们有一些外部影响的指标，将帮助我们的控制变得更加多样。

#### 输出功率分配
积分值越高，表明有一些外部影响减慢了我们的系统。因此，为了对抗这一点，我们增加一些额外的功率来给予更多的“推动”，为了完成这一点，我们将积分加到现有的输出中。为了像我们为比例项看到的那样解决缩放问题，我们引入了另一个常数 - kI。正如你可能猜到的，我们的积分可能将是一个巨大的数字，因此作为输出功率完全无用，因此我们通常期望 kI 与 kP 相比相当小，特别是在我们忽略 dT 的情况下。

```c++
power = error*kP + integral*kI 
```

我们的代码现在看起来有点像这样：

```c++
void myPID(int setpoint) {
    while (condition) {
        error = setpoint – sensor value;
        integral = integral + error; 
        power = error*kP + integral*kI;
        wait(15,msec);
    }
}
```

末尾的 15 毫秒等待非常重要——这是我们的 dT。没有它，积分值将飙升到一个巨大的数字，因为数字在没有停止间隔的情况下被加在一起，15 毫秒对于大多数我们的用途来说已经足够快了，以实现准确的积分。这个延迟也将很快被证明对微分项至关重要，我确信当我们到达那部分时，您会意识到。如果你不考虑一个恒定的 dT，你需要测量每次循环的时间，并在积分计算中考虑这一点。

#### 一些问题

##### 问题1：积分置0
当误差达到零时，也就是说系统已经到达设定点，积分最有可能仍然足够显著，以保持输出功率足够高以继续。这在系统不需要任何额外功率来保持位置的情况下可能是一个麻烦：例如，如果这是用于平坦表面上的驱动系统，如果轮子在到达目标值后继续转动，这多少有些问题。

在这些情况下，我们可以在误差通过设定点时将积分重置为零，如下所示：

```c++
void myPID(int setpoint) {
    while (condition) {
        error = setpoint – sensor value;
        integral = integral + error;
        if (error = 0 or passes setpoint) integral = 0; 
        power = error*kP + integral*kI;
        wait(15,msec);
    }
}
```

注意：如果此 PID 控制器是用于需要一点功率输出来保持其位置的系统（例如，举起一些重量的抬升臂），你绝对不应该尝试这样做。当误差通过设定点时，积分值将逐渐减少，它仍然会稳定下来。这仅适用于那些在没有功率的情况下保持其传感器值的系统（例如，在平坦表面上的轮子）。

##### 问题2：积分饱和现象
积分饱和是一个问题。当设定点发生大的变化（例如，0 到 1000），导致积分开始为巨大的误差值计算。然后，当系统真正需要它时（即，接近设定点时），这会导致积分成为一个巨大无比的值，这几乎无法使用。有几种方法可以解决这个问题：

1. 限制积分的最值

```c++
if (integral is huge) integral = maximum value;
```

2. 限制允许积分建立的范围
一旦误差低于某个值，或者一旦当前输出功率小于某个值，代表积分饱和，直接放弃本次的值。

```c++
if ( error is big ) integral = 0; 
```

3. 逐渐增加它的先前值（例如 0）与新值（例如 1000）之间的误差。这在编程上稍微复杂一些，但仍然是可行的。

对于本教程，我们将使用第二个解决方案，使用误差作为限制因素。

#### 改进的代码
我们到目前为止创建的 PI 控制器看起来有点像这样：

```c++
void myPID(int setpoint) 
{ 
    while ( some condition ) { 
        error = setpoint – sensor value; 
        integral = integral + error; 
        if (error = 0 or passes setpoint) 
        integral = 0; 
        if (error is outside useful range) 
        integral = 0; 
        power = error*kP + integral*kI; 
        wait(15,msec); 
    } 
} 
```

***

### D：微分（Derivative）
到目前为止，我们已经讨论了如何根据当前误差和过去误差来控制输出。现在，我们将开始**预测未来**。微分项的核心思想是：**观察误差的变化速率** —— 我们正在以多快的速度接近目标？是否需要提前减速？微分项的作用方向通常与当前运动方向相反，速度越快，微分项的影响越大。虽然它通常没有比例和积分项那么强，但如果机器人因为某种原因移动得比预期更快，微分项会变大，从而降低输出功率，达到提前减速的效果。反之，如果机器人移动得比预期慢，微分项影响变小，输出功率就会增加。

#### 理解微分
如前所述，微分就是变化率。在微积分中，它也代表曲线的斜率。曲线越陡，斜率越大，微分值也越大。

![PID3](/attachment/picture/PID3.PNG)

我们通常用以下公式来计算斜率：

![PID4](/attachment/picture/PID4.PNG)

在我们的系统中，Y轴是误差，X轴是时间（dT），因此微分计算公式为：

![PID5](/attachment/picture/PID5.PNG)

与积分类似，如果我们将 dT 视为常数，也可以将其合并进系数中，从而简化计算。
我们只需新增一个变量 prevError 来记录上一次的误差值：

```c++
derivative = error - prevError
prevError = error
```

#### 输出功率分配
与比例和积分项一样，我们为微分项也引入一个系数 kD，用于调节其影响力。
如果 kD 太大，系统会变得不稳定，因为微分项会短暂地“压倒”其他两项，导致输出异常。
如果 kD 太小，微分项几乎不起作用，等于没有。
我们将微分项加入总输出功率中：

```c++
power = error * kP + integral * kI + derivative * kD
```

至此，我们的 PID 控制伪代码如下：

```c++
void myPID(int setpoint) {
    while (some condition) {
        error = setpoint - sensor_value;
        integral = integral + error;
        if (error == 0 or passes setpoint)
            integral = 0;
        if (error is outside useful range)
            integral = 0;
        derivative = error - prevError;
        prevError = error;
        power = error * kP + integral * kI + derivative * kD;
        wait 15mSec;
    }
}
```

***

### 参数整定
PID 控制器最耗时、最繁琐、最令人头疼的部分就是参数整定。你需要调节 kP、kI、kD 三个参数，使系统响应快速、稳定、准确。

#### 参数对系统性能的影响
|  参数 |  上升时间  |   超调量  |  稳定时间  |  稳态误差  |  稳定性 |
| :-: | :----: | :----: | :----: | :----: | :--: |
|  kP | 减小（更快） | 增加（更远） |  无显著影响 | 减小（更准） |  变差  |
|  kI | 减小（更快） | 增加（更远） | 增加（更慢） | 减小（更准） |  变差  |
|  kD |  无显著影响 | 减小（更近） | 减小（更快） |  无显著影响 | 改善 |

:warning: kD 太大会反而让系统不稳定！

#### 手动试凑法
这是最常见的调参方法，步骤如下：
1. 先将 kP、kI、kD 全部设为 0。
2. 逐步增大 kP，直到机器人开始轻微振荡（1~2次）。此时运动应较快但不剧烈。
3. 加入 kD，逐步增大，直到超调减小，系统更平稳。可能需要微调 kP。
4. 最后加入 kI，消除小的稳态误差。此时可能需再微调 kD。

:warning: 注意：调参时务必随时准备手动停止机器人，避免参数过大导致失控！

#### 数学整定法
这是一种更系统的调参方法，适合有一定经验的用户，步骤如下：
1. 先将 kI 和 kD 设为 0。
2. 逐步增大 kP，直到系统出现持续稳定的振荡，记录此时的 kP 值为 kU（临界增益）。
3. 测量振荡周期，记为 pU（临界周期）。

根据控制器类型，使用下表计算参数：

| 控制器类型 |     kP     |        kI       |         kD        |
| :---: | :--------: | :-------------: | :---------------: |
|   P   |  0.5 \* kU |        0        |         0         |
|   PI  | 0.45 \* kU | 0.54 \* kU / pU |         0         |
|   PD  |  0.8 \* kU |        0        |  0.1 \* kU \* pU  |
|  PID  |  0.6 \* kU |  1.2 \* kU / pU | 0.075 \* kU \* pU |

:warning: 注意：最终仍需手动微调，因为表格未考虑 dT 的影响。

***
#### :door: [回到编程](/programming/programming.md)